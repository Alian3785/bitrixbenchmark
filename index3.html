<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ö–û–°–ú–ò–ß–ï–°–ö–û–ï –ü–£–¢–ï–®–ï–°–¢–í–ò–ï –°–ï–†–ï–ñ–ò</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #05060a; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas{ display:block; }

    #hud{
      position: fixed; left: 14px; top: 14px; z-index: 10;
      color: #e9eefc; max-width: 820px;
      background: rgba(10, 14, 24, .60);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 12px 12px 10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      pointer-events: none;
    }
    #title{ font-weight: 1000; letter-spacing: .8px; font-size: 15px; opacity: .98; }
    #info{ margin-top: 8px; line-height: 1.25; font-size: 13px; color: rgba(233,238,252,.92); }
    #info .big{ font-size: 15px; font-weight: 900; margin-bottom: 6px; }
    #info .row{ opacity: .92; margin-top: 4px; }
    #info .label{ opacity: .75; margin-right: 6px; }

    #details{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,.10);
      display: none;
    }
    #details ul{ margin: 6px 0 0 18px; padding: 0; }
    #details li{ margin: 4px 0; }

    #barWrap{
      margin-top: 10px;
      height: 8px; border-radius: 999px;
      background: rgba(255,255,255,.10);
      overflow: hidden;
    }
    #bar{
      height: 100%;
      width: 0%;
      background: rgba(233,238,252,.78);
    }
    #hint{
      margin-top: 10px;
      font-size: 12px;
      opacity: .84;
    }

    #floatingLabel{
      position: fixed; z-index: 9; pointer-events: none;
      transform: translate(-50%, -50%);
      padding: 7px 9px; border-radius: 12px;
      background: rgba(10, 14, 24, .72);
      border: 1px solid rgba(255,255,255,.12);
      color: #e9eefc; font-size: 12px; line-height: 1.2;
      opacity: 0; transition: opacity .25s ease;
      white-space: nowrap;
    }
    #floatingLabel .name{ font-weight: 900; }
    #floatingLabel .meta{ opacity: .88; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="title">–ö–û–°–ú–ò–ß–ï–°–ö–û–ï –ü–£–¢–ï–®–ï–°–¢–í–ò–ï –°–ï–†–ï–ñ–ò</div>

    <div id="info"></div>

    <div id="details">
      <div class="row"><span class="label">–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π —Ñ–∞–∫—Ç:</span><span id="fact"></span></div>
      <div class="row"><span class="label">–ü–ª–∞–Ω–µ—Ç—ã:</span>
        <ul id="planets"></ul>
      </div>
    </div>

    <div id="barWrap"><div id="bar"></div></div>
    <div id="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –¥–µ—Ä–∂–∏ –ü–†–û–ë–ï–õ —á—Ç–æ–±—ã –ª–µ—Ç–µ—Ç—å ‚Ä¢ –ö–æ–ª–µ—Å–æ –º—ã—à–∏ = –∑—É–º ‚Ä¢ –û–∑–≤—É—á–∫–∞ –∏ –º—É–∑—ã–∫–∞ –≤–∫–ª—é—á–∞—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –ü–†–û–ë–ï–õ</div>
  </div>

  <div id="floatingLabel">
    <div class="name" id="flName"></div>
    <div class="meta" id="flMeta"></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // --------------------------
    // –î–ê–ù–ù–´–ï (+ rsun: —Ä–∞–¥–∏—É—Å –≤ —Ä–∞–¥–∏—É—Å–∞—Ö –°–æ–ª–Ω—Ü–∞)
    // --------------------------
    const STARS = [
      { ruName:"–ü—Ä–æ–∫—Å–∏–º–∞ –¶–µ–Ω—Ç–∞–≤—Ä–∞", name:"Proxima Centauri", spec:"M5.5Ve", distLy:4.2465, rsun:0.154, ra:[14,29,43.0], dec:[-62,40,46],
        fact:"–°–∞–º–∞—è –±–ª–∏–∑–∫–∞—è –∫ –Ω–∞–º –∑–≤–µ–∑–¥–∞ –ø–æ—Å–ª–µ –°–æ–ª–Ω—Ü–∞. –ù–æ –æ–Ω–∞ –æ—á–µ–Ω—å —Ç—É—Å–∫–ª–∞—è ‚Äî –≥–ª–∞–∑–æ–º –µ—ë –Ω–µ —É–≤–∏–¥–µ—Ç—å.",
        planets:[
          { name:"Proxima b", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–ø–æ—Ö–æ–∂–∞ –Ω–∞ ‚Äú—Å—É–ø–µ—Ä-–ó–µ–º–ª—é‚Äù", period:"11.2 –¥–Ω—è", au:"0.048 AU" },
          { name:"Proxima d", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–º–∞–ª–µ–Ω—å–∫–∞—è –∫–∞–º–µ–Ω–Ω–∞—è", period:"5.1 –¥–Ω—è", au:"0.029 AU" },
          { name:"Proxima c", status:"–∫–∞–Ω–¥–∏–¥–∞—Ç", simple:"—É—á—ë–Ω—ã–µ –µ—â—ë –ø—Ä–æ–≤–µ—Ä—è—é—Ç", period:"‚Äî", au:"‚Äî" },
        ]},
      { ruName:"–ê–ª—å—Ñ–∞ –¶–µ–Ω—Ç–∞–≤—Ä–∞ –ê", name:"Alpha Centauri A", spec:"G2V", distLy:4.3441, rsun:1.2175, ra:[14,39,36.5], dec:[-60,50, 2],
        fact:"–ü–æ—Ö–æ–∂–∞ –Ω–∞ –°–æ–ª–Ω—Ü–µ. –í–º–µ—Å—Ç–µ —Å –ê–ª—å—Ñ–∞ –¶–µ–Ω—Ç–∞–≤—Ä–∞ –ë –æ–Ω–∏ –∫—Ä—É–∂–∞—Ç—Å—è –¥—Ä—É–≥ –≤–æ–∫—Ä—É–≥ –¥—Ä—É–≥–∞, –∫–∞–∫ –ø–∞—Ä–∞ —Ç–∞–Ω—Ü–æ—Ä–æ–≤.",
        planets:[{ name:"(–ø–æ–∫–∞ –Ω–µ—Ç)", status:"", simple:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏ (–∏—â—É—Ç!)", period:"", au:"" }]},
      { ruName:"–ê–ª—å—Ñ–∞ –¶–µ–Ω—Ç–∞–≤—Ä–∞ –ë", name:"Alpha Centauri B", spec:"K1V", distLy:4.3441, rsun:0.8591, ra:[14,39,35.1], dec:[-60,50,14],
        fact:"–ß—É—Ç—å –ø—Ä–æ—Ö–ª–∞–¥–Ω–µ–µ –°–æ–ª–Ω—Ü–∞. –û–Ω–∞ ‚Äî —á–∞—Å—Ç—å —Å–∞–º–æ–π –±–ª–∏–∑–∫–æ–π –∫ –Ω–∞–º –∑–≤—ë–∑–¥–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã.",
        planets:[{ name:"(–ø–æ–∫–∞ –Ω–µ—Ç)", status:"", simple:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏", period:"", au:"" }]},
      { ruName:"–ó–≤–µ–∑–¥–∞ –ë–∞—Ä–Ω–∞—Ä–¥–∞", name:"Barnard's Star", spec:"M4.0Ve", distLy:5.9629, rsun:0.20, ra:[17,57,48.5], dec:[  4,41,36],
        fact:"–≠—Ç–∞ –∑–≤–µ–∑–¥–∞ –±—ã—Å—Ç—Ä–æ ‚Äú–ø–æ–ª–∑—ë—Ç‚Äù –ø–æ –Ω–µ–±—É ‚Äî –µ—ë –ø–æ–ª–æ–∂–µ–Ω–∏–µ –∑–∞–º–µ—Ç–Ω–æ –º–µ–Ω—è–µ—Ç—Å—è —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º.",
        planets:[
          { name:"Barnard d", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∞—è", period:"2.34 –¥–Ω—è", au:"‚Äî" },
          { name:"Barnard b", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∞—è", period:"3.15 –¥–Ω—è", au:"‚Äî" },
          { name:"Barnard c", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∞—è", period:"4.12 –¥–Ω—è", au:"‚Äî" },
          { name:"Barnard e", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∞—è", period:"6.74 –¥–Ω—è", au:"‚Äî" },
        ]},
      { ruName:"–í–æ–ª—å—Ñ 359", name:"Wolf 359", spec:"M6V", distLy:7.8558, rsun:0.144, ra:[10,56,29.2], dec:[  7, 0,53],
        fact:"–û—á–µ–Ω—å —Ç—É—Å–∫–ª–∞—è –∑–≤–µ–∑–¥–∞. –ò–Ω–æ–≥–¥–∞ –º–æ–∂–µ—Ç —Ä–µ–∑–∫–æ ‚Äú–≤—Å–ø—ã—Ö–∏–≤–∞—Ç—å‚Äù –Ω–∞ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è.",
        planets:[{ name:"(–ø–æ–∫–∞ –Ω–µ—Ç)", status:"", simple:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏", period:"", au:"" }]},
      { ruName:"–õ–∞–ª–∞–Ω–¥ 21185 (–î–∂–∏-–î–∂–µ–π 411)", name:"Lalande 21185 (GJ 411)", spec:"M2.0V", distLy:8.3044, rsun:0.392, ra:[11, 3,20.2], dec:[ 35,58,12],
        fact:"–û–¥–∏–Ω –∏–∑ –Ω–∞—à–∏—Ö –±–ª–∏–∑–∫–∏—Ö —Å–æ—Å–µ–¥–µ–π-–∫—Ä–∞—Å–Ω—ã—Ö –∫–∞—Ä–ª–∏–∫–æ–≤. –ï–≥–æ —á–∞—Å—Ç–æ –∏–∑—É—á–∞—é—Ç –∏–∑-–∑–∞ –±–ª–∏–∑–æ—Å—Ç–∏.",
        planets:[
          { name:"GJ 411 b", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"‚Äú—Å—É–ø–µ—Ä-–ó–µ–º–ª—è‚Äù", period:"12.94 –¥–Ω—è", au:"0.0788 AU" },
          { name:"HD 95735 c", status:"–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞", simple:"–±–æ–ª–µ–µ —Ç—è–∂—ë–ª–∞—è –∏ –¥–∞–ª—ë–∫–∞—è", period:"‚âà 2946 –¥–Ω–µ–π", au:"‚âà 3 AU" },
        ]},
      { ruName:"–°–∏—Ä–∏—É—Å –ê", name:"Sirius A", spec:"A1V", distLy:8.7094, rsun:1.71, ra:[ 6,45, 8.9], dec:[-16,42,58],
        fact:"–°–∞–º–∞—è —è—Ä–∫–∞—è –∑–≤–µ–∑–¥–∞ –Ω–æ—á–Ω–æ–≥–æ –Ω–µ–±–∞! –£ –Ω–µ—ë –µ—Å—Ç—å ‚Äú–Ω–∞–ø–∞—Ä–Ω–∏–∫‚Äù ‚Äî –±–µ–ª—ã–π –∫–∞—Ä–ª–∏–∫ –°–∏—Ä–∏—É—Å –ë.",
        planets:[{ name:"(–ø–æ–∫–∞ –Ω–µ—Ç)", status:"", simple:"–ø–ª–∞–Ω–µ—Ç –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏", period:"", au:"" }]},
      { ruName:"–°–∏—Ä–∏—É—Å –ë", name:"Sirius B", spec:"DA2", distLy:8.7094, rsun:0.008, ra:[ 6,45, 8.9], dec:[-16,42,58],
        fact:"–ë–µ–ª—ã–π –∫–∞—Ä–ª–∏–∫: –º–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä, –Ω–æ –æ–≥—Ä–æ–º–Ω–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å ‚Äî –∫–∞–∫ ‚Äú–∑–≤—ë–∑–¥–Ω—ã–π –∫–∞–º–µ–Ω—å‚Äù.",
        planets:[{ name:"(–ø–æ–∫–∞ –Ω–µ—Ç)", status:"", simple:"–ø–ª–∞–Ω–µ—Ç –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏", period:"", au:"" }]},
      { ruName:"–ì–ª–∏–∑–µ 65 –ê (–ë–∏-–≠–ª –¶–µ—Ç–∏)", name:"Gliese 65 A (BL Ceti)", spec:"M5.5Ve", distLy:8.7240, rsun:0.165, ra:[ 1,39, 1.3], dec:[-17,57, 1],
        fact:"–≠—Ç–æ –∑–≤–µ–∑–¥–∞-–≤—Å–ø—ã—à–∫–∞: –∏–Ω–æ–≥–¥–∞ —Ä–µ–∑–∫–æ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —è—Ä—á–µ, –∞ –ø–æ—Ç–æ–º —Å–Ω–æ–≤–∞ —Ç—É—Å–∫–Ω–µ–µ—Ç.",
        planets:[{ name:"(–∫–∞–Ω–¥–∏–¥–∞—Ç)", status:"–∫–∞–Ω–¥–∏–¥–∞—Ç", simple:"–µ—Å—Ç—å –Ω–∞–º—ë–∫, –Ω–æ –µ—â—ë –Ω–µ –¥–æ–∫–∞–∑–∞–Ω–æ", period:"‚Äî", au:"‚Äî" }]},
      { ruName:"–ì–ª–∏–∑–µ 65 –ë (–Æ-–í–∏ –¶–µ—Ç–∏)", name:"Gliese 65 B (UV Ceti)", spec:"M6.0Ve", distLy:8.7240, rsun:0.159, ra:[ 1,39, 1.3], dec:[-17,57, 1],
        fact:"–û—á–µ–Ω—å –∏–∑–≤–µ—Å—Ç–Ω–∞—è ‚Äú—Ñ–ª–µ–π—Ä-–∑–≤–µ–∑–¥–∞‚Äù: –≤—Å–ø—ã—à–∫–∏ –±—ã–≤–∞—é—Ç —Å–∏–ª—å–Ω—ã–º–∏ –∏ –±—ã—Å—Ç—Ä—ã–º–∏.",
        planets:[{ name:"(–∫–∞–Ω–¥–∏–¥–∞—Ç)", status:"–∫–∞–Ω–¥–∏–¥–∞—Ç", simple:"–µ—Å–ª–∏ –ø–ª–∞–Ω–µ—Ç–∞ –µ—Å—Ç—å ‚Äî —É—á—ë–Ω—ã–º –Ω—É–∂–Ω–æ —ç—Ç–æ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", period:"‚Äî", au:"‚Äî" }]},
    ];

    // --------------------------
    // –£–¢–ò–õ–ò–¢–´
    // --------------------------
    function raToRad([h,m,s]){ return THREE.MathUtils.degToRad(15 * (h + m/60 + s/3600)); }
    function decToRad([d,m,s]){
      const sign = d < 0 ? -1 : 1;
      const ad = Math.abs(d) + m/60 + s/3600;
      return THREE.MathUtils.degToRad(sign * ad);
    }

    function eqToPlaneXY(distLy, raHms, decDms){
      const ra = raToRad(raHms);
      const dec = decToRad(decDms);
      const cosDec = Math.cos(dec);
      const x3 = distLy * cosDec * Math.cos(ra);
      const y3 = distLy * cosDec * Math.sin(ra);
      const rxy = Math.hypot(x3, y3);
      if (rxy < 1e-9) return new THREE.Vector3(distLy, 0, 0);
      const s = distLy / rxy;
      return new THREE.Vector3(x3 * s, y3 * s, 0);
    }

    function colorBySpec(spec){
      const s = (spec || "").trim().toUpperCase();
      const c = s[0] || "G";
      const map = {
        "O": 0x9bb0ff, "B": 0xaabfff, "A": 0xcad7ff, "F": 0xf8f7ff,
        "G": 0xfff4d6, "K": 0xffd2a1, "M": 0xffb08a, "D": 0xd9f2ff
      };
      return map[c] ?? 0xffffff;
    }

    function kidStarType(spec){
      const s = (spec || "").toUpperCase();
      const c = s[0] || "G";
      if (c === "M") return "–∫—Ä–∞—Å–Ω—ã–π –∫–∞—Ä–ª–∏–∫ (–º–∞–ª–µ–Ω—å–∫–∞—è –∏ –ø—Ä–æ—Ö–ª–∞–¥–Ω–µ–µ –°–æ–ª–Ω—Ü–∞)";
      if (c === "K") return "–æ—Ä–∞–Ω–∂–µ–≤–∞—è –∑–≤–µ–∑–¥–∞ (—á—É—Ç—å –ø—Ä–æ—Ö–ª–∞–¥–Ω–µ–µ –°–æ–ª–Ω—Ü–∞)";
      if (c === "G") return "–∂—ë–ª—Ç–∞—è –∑–≤–µ–∑–¥–∞ (–∫–∞–∫ –°–æ–ª–Ω—Ü–µ)";
      if (c === "F") return "–±–µ–ª–æ-–∂—ë–ª—Ç–∞—è –∑–≤–µ–∑–¥–∞ (–≥–æ—Ä—è—á–µ–µ –°–æ–ª–Ω—Ü–∞)";
      if (c === "A") return "–±–µ–ª–∞—è –∑–≤–µ–∑–¥–∞ (–Ω–∞–º–Ω–æ–≥–æ –≥–æ—Ä—è—á–µ–µ –°–æ–ª–Ω—Ü–∞)";
      if (c === "B") return "–≥–æ–ª—É–±–æ–≤–∞—Ç–æ-–±–µ–ª–∞—è (–æ—á–µ–Ω—å –≥–æ—Ä—è—á–∞—è)";
      if (c === "O") return "–≥–æ–ª—É–±–∞—è (—Å—É–ø–µ—Ä-–≥–æ—Ä—è—á–∞—è)";
      if (c === "D") return "–±–µ–ª—ã–π –∫–∞—Ä–ª–∏–∫ (–º–∞–ª–µ–Ω—å–∫–∏–π, –Ω–æ –æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω—ã–π)";
      return "–∑–≤–µ–∑–¥–∞ (—Ä–µ–¥–∫–∏–π —Ç–∏–ø)";
    }

    // ‚úÖ –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ —Ü–µ–ª—ã—Ö
    function kidDistance(distLy){
      const ly = Math.max(1, Math.round(distLy));
      return `${ly} —Å–≤–µ—Ç–æ–≤—ã—Ö –ª–µ—Ç (—Å–≤–µ—Ç –ª–µ—Ç–µ–ª –±—ã –ø—Ä–∏–º–µ—Ä–Ω–æ ${ly} –ª–µ—Ç)`;
    }

    // ‚úÖ –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ —Ü–µ–ª—ã—Ö
    function kidSize(rsun){
      if (!isFinite(rsun) || rsun <= 0) return "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ";
      if (rsun >= 0.8 && rsun <= 1.25) return "–ø—Ä–∏–º–µ—Ä–Ω–æ –∫–∞–∫ –°–æ–ª–Ω—Ü–µ";
      if (rsun >= 1.0){
        const times = Math.max(1, Math.round(rsun));
        return `–ø—Ä–∏–º–µ—Ä–Ω–æ –≤ ${times} —Ä–∞–∑ –±–æ–ª—å—à–µ –°–æ–ª–Ω—Ü–∞`;
      } else {
        const times = Math.max(1, Math.round(1 / rsun));
        return `–ø—Ä–∏–º–µ—Ä–Ω–æ –≤ ${times} —Ä–∞–∑ –º–µ–Ω—å—à–µ –°–æ–ª–Ω—Ü–∞`;
      }
    }

    // —Ä–∞–∑–º–µ—Ä –∫—Ä—É–∂–∫–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç rsun (–≤–∏–∑—É–∞–ª—å–Ω–æ ¬´—Å–∂–∞—Ç—ã–π¬ª, —á—Ç–æ–±—ã –≤—Å—ë –±—ã–ª–æ –≤–∏–¥–Ω–æ)
    function visualStarRadius(rsun, spec){
      const s = (spec || "").toUpperCase();
      const isWhiteDwarf = s.startsWith("D");
      const r = (isFinite(rsun) && rsun > 0) ? rsun : 0.6;

      const base = isWhiteDwarf ? 0.030 : 0.050;
      const k = isWhiteDwarf ? 0.40 : 0.18;

      const vis = base + k * r;
      return THREE.MathUtils.clamp(vis, 0.020, 0.36);
    }

    // ‚úÖ –í–∏–∑—É–∞–ª—å–Ω–æ —Ä–∞–∑–≤–æ–¥–∏–º —Å–∏—Å—Ç–µ–º—É –¶–µ–Ω—Ç–∞–≤—Ä–∞, —á—Ç–æ–±—ã –∑–≤—ë–∑–¥—ã –Ω–µ –∑–∞—Å–ª–æ–Ω—è–ª–∏ –¥—Ä—É–≥ –¥—Ä—É–≥–∞
    function applyCentauriVisualSplit(st){
      const dir = st.pos.clone().normalize();
      const perp = new THREE.Vector3(-dir.y, dir.x, 0);

      if (st.name === "Alpha Centauri A") {
        st.pos.add(perp.multiplyScalar(0.55));
      } else if (st.name === "Alpha Centauri B") {
        st.pos.add(perp.multiplyScalar(-0.55));
      } else if (st.name === "Proxima Centauri") {
        st.pos.add(perp.multiplyScalar(0.25));
      }
    }

    function bezier(p0, p1, p2, t){
      const a = p0.clone().lerp(p1, t);
      const b = p1.clone().lerp(p2, t);
      return a.lerp(b, t);
    }

    function projectToScreen(pos, camera){
      const v = pos.clone().project(camera);
      return {
        x: (v.x * 0.5 + 0.5) * window.innerWidth,
        y: (-v.y * 0.5 + 0.5) * window.innerHeight,
        inFront: v.z < 1
      };
    }

    function tForArcLen(samples, s){
      const { cum, total } = samples;
      if (s <= 0) return 0;
      if (s >= total) return 1;

      let lo = 0, hi = cum.length - 1;
      while (lo < hi){
        const mid = (lo + hi) >> 1;
        if (cum[mid] < s) lo = mid + 1; else hi = mid;
      }
      const i = Math.max(1, lo);
      const s0 = cum[i-1], s1 = cum[i];
      const t0 = (i-1) / (cum.length - 1);
      const t1 = i / (cum.length - 1);
      const f = (s - s0) / Math.max(1e-9, (s1 - s0));
      return t0 + (t1 - t0) * f;
    }

    function buildArcSamples(p0, p1, p2, n = 700){
      const cum = new Float32Array(n);
      let total = 0;
      let prev = bezier(p0, p1, p2, 0);
      cum[0] = 0;
      for (let i=1;i<n;i++){
        const t = i / (n - 1);
        const cur = bezier(p0, p1, p2, t);
        total += cur.distanceTo(prev);
        cum[i] = total;
        prev = cur;
      }
      return { cum, total };
    }

    // --------------------------
    // –°–¶–ï–ù–ê + –ö–ê–ú–ï–†–ê + –ó–£–ú
    // --------------------------
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -10, 10);
    camera.position.set(0, 0, 5);
    camera.lookAt(0,0,0);

    const camFrame = { center: new THREE.Vector3(0,0,0), halfH: 6.0 };
    const camFrameTarget = { center: new THREE.Vector3(0,0,0), halfH: 6.0 };
    let userZoom = 1.0;

    function applyOrthoFrame(frame){
      const aspect = window.innerWidth / window.innerHeight;
      const halfH = frame.halfH;
      const halfW = halfH * aspect;
      camera.left = frame.center.x - halfW;
      camera.right = frame.center.x + halfW;
      camera.top = frame.center.y + halfH;
      camera.bottom = frame.center.y - halfH;
      camera.updateProjectionMatrix();
    }

    function updateOrthoSmooth(dt){
      const k = 1 - Math.pow(0.001, dt);
      camFrame.center.lerp(camFrameTarget.center, k);
      camFrame.halfH = THREE.MathUtils.lerp(camFrame.halfH, camFrameTarget.halfH, k);
      applyOrthoFrame(camFrame);
    }

    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY);
      const factor = delta > 0 ? 1.08 : 0.92;
      userZoom = THREE.MathUtils.clamp(userZoom * factor, 0.55, 2.4);
    }, { passive: false });

    // --------------------------
    // –§–û–ù
    // --------------------------
    {
      const N = 1700;
      const positions = new Float32Array(N * 3);
      const R = 260;
      for (let i=0;i<N;i++){
        positions[3*i+0] = (Math.random()*2 - 1) * R;
        positions[3*i+1] = (Math.random()*2 - 1) * R;
        positions[3*i+2] = -0.8;
      }
      const g = new THREE.BufferGeometry();
      g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      scene.add(new THREE.Points(g, new THREE.PointsMaterial({ size: 0.55, transparent: true, opacity: 0.55 })));
    }

    // --------------------------
    // –°–û–õ–ù–¶–ï
    // --------------------------
    const SUN_VIS_RADIUS = 0.34;

    const sun = new THREE.Mesh(
      new THREE.CircleGeometry(SUN_VIS_RADIUS, 72),
      new THREE.MeshBasicMaterial({ color: 0xfff1b8 })
    );
    scene.add(sun);

    const sunHalo = new THREE.Mesh(
      new THREE.CircleGeometry(SUN_VIS_RADIUS * 1.70, 72),
      new THREE.MeshBasicMaterial({ color: 0xffe6a6, transparent: true, opacity: 0.12 })
    );
    sunHalo.position.z = -0.02;
    scene.add(sunHalo);

    // --------------------------
    // –ö–û–õ–¨–¶–ê
    // --------------------------
    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    const rings = [];
    function makeRing(radius){
      const seg = 180;
      const pts = [];
      for(let i=0;i<=seg;i++){
        const t = (i/seg) * Math.PI*2;
        pts.push(new THREE.Vector3(Math.cos(t)*radius, Math.sin(t)*radius, 0));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
      return new THREE.Line(geom, mat);
    }
    const MAX_RING = 12;
    for (let r=1; r<=MAX_RING; r++){
      const ring = makeRing(r);
      rings.push({ r, ring });
      ringGroup.add(ring);
    }

    let visibleRings = 4;
    function updateRings(){
      for (const {r, ring} of rings){
        ring.material.opacity = (r <= visibleRings) ? 0.20 : 0.0;
      }
    }
    updateRings();

    // --------------------------
    // –ó–í–Å–ó–î–´
    // --------------------------
    const starGroup = new THREE.Group();
    const rayGroup = new THREE.Group();
    scene.add(starGroup);
    scene.add(rayGroup);

    const starRays = [];

    STARS.forEach((st) => {
      st.pos = eqToPlaneXY(st.distLy, st.ra, st.dec);
      applyCentauriVisualSplit(st);

      const col = colorBySpec(st.spec);
      const radius = visualStarRadius(st.rsun, st.spec);

      const star = new THREE.Mesh(
        new THREE.CircleGeometry(radius, 56),
        new THREE.MeshBasicMaterial({ color: col })
      );
      star.position.copy(st.pos);
      starGroup.add(star);

      const glow = new THREE.Mesh(
        new THREE.CircleGeometry(radius * 2.3, 56),
        new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.14 })
      );
      glow.position.copy(st.pos);
      glow.position.z = -0.03;
      starGroup.add(glow);

      const rayGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), st.pos.clone()]);
      const rayMat = new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.05 });
      const ray = new THREE.Line(rayGeom, rayMat);
      rayGroup.add(ray);
      starRays.push(ray);
    });

    // --------------------------
    // –ö–û–†–ê–ë–õ–¨ (—Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π 2D)
    // --------------------------
    const ship = new THREE.Group();
    scene.add(ship);

    function roundedRectShape(w, h, r){
      const s = new THREE.Shape();
      const x = -w/2, y = -h/2;
      s.moveTo(x+r, y);
      s.lineTo(x+w-r, y);
      s.quadraticCurveTo(x+w, y, x+w, y+r);
      s.lineTo(x+w, y+h-r);
      s.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      s.lineTo(x+r, y+h);
      s.quadraticCurveTo(x, y+h, x, y+h-r);
      s.lineTo(x, y+r);
      s.quadraticCurveTo(x, y, x+r, y);
      return s;
    }

    const BODY_LEN = 0.46;
    const BODY_W   = 0.18;

    // –∫–æ—Ä–ø—É—Å
    {
      const shape = roundedRectShape(BODY_LEN, BODY_W, 0.06);
      const geom = new THREE.ShapeGeometry(shape);
      const mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0xf2f6ff }));
      mesh.position.set(0, 0, 0.09);
      ship.add(mesh);

      const pts = shape.getPoints(80).map(p => new THREE.Vector3(p.x, p.y, 0.095));
      ship.add(new THREE.LineLoop(
        new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineBasicMaterial({ color: 0x9bb0ff, transparent: true, opacity: 0.9 })
      ));
    }

    // –Ω–æ—Å
    {
      const s = new THREE.Shape();
      s.moveTo(BODY_LEN/2, 0);
      s.lineTo(BODY_LEN/2 - 0.14, 0.12);
      s.lineTo(BODY_LEN/2 - 0.14, -0.12);
      s.closePath();
      const geom = new THREE.ShapeGeometry(s);
      const nose = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0xffffff }));
      nose.position.set(0,0,0.10);
      ship.add(nose);

      const pts = s.getPoints(10).map(p => new THREE.Vector3(p.x, p.y, 0.105));
      ship.add(new THREE.LineLoop(
        new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineBasicMaterial({ color: 0xbfd0ff, transparent: true, opacity: 0.9 })
      ));
    }

    // –∫—Ä—ã–ª—å—è
    function addFin(sign){
      const fin = new THREE.Shape();
      fin.moveTo(-0.05, 0);
      fin.lineTo(0.12, 0.06 * sign);
      fin.lineTo(0.10, 0.16 * sign);
      fin.closePath();
      const geom = new THREE.ShapeGeometry(fin);
      const mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0xa6b9ff, transparent: true, opacity: 0.95 }));
      mesh.position.set(-0.02, 0, 0.085);
      ship.add(mesh);
    }
    addFin(1);
    addFin(-1);

    // –∏–ª–ª—é–º–∏–Ω–∞—Ç–æ—Ä
    {
      const wnd = new THREE.Mesh(
        new THREE.CircleGeometry(0.035, 24),
        new THREE.MeshBasicMaterial({ color: 0x9bb0ff, transparent: true, opacity: 0.9 })
      );
      wnd.position.set(0.05, 0.0, 0.11);
      ship.add(wnd);

      const ring = new THREE.Mesh(
        new THREE.RingGeometry(0.038, 0.046, 28),
        new THREE.MeshBasicMaterial({ color: 0xe9eefc, transparent: true, opacity: 0.75 })
      );
      ring.position.set(0.05, 0.0, 0.115);
      ship.add(ring);
    }

    // –ø–ª–∞–º—è
    const flame = (() => {
      const s = new THREE.Shape();
      s.moveTo(-BODY_LEN/2 - 0.06, 0);
      s.lineTo(-BODY_LEN/2 + 0.02, 0.07);
      s.lineTo(-BODY_LEN/2 + 0.02, -0.07);
      s.closePath();
      const geom = new THREE.ShapeGeometry(s);
      const mat = new THREE.MeshBasicMaterial({ color: 0x9bb0ff, transparent: true, opacity: 0.0 });
      const m = new THREE.Mesh(geom, mat);
      m.position.set(0,0,0.08);
      return m;
    })();
    ship.add(flame);

    // --------------------------
    // HUD
    // --------------------------
    const elInfo = document.getElementById("info");
    const elDetails = document.getElementById("details");
    const elFact = document.getElementById("fact");
    const elPlanets = document.getElementById("planets");
    const elBar = document.getElementById("bar");

    const floating = document.getElementById("floatingLabel");
    const flName = document.getElementById("flName");
    const flMeta = document.getElementById("flMeta");

    function setInfo(st, phaseText){
      elInfo.innerHTML = `
        <div class="big">–¶–µ–ª—å: ${st.ruName}</div>
        <div class="row"><span class="label">–¢–∏–ø –∑–≤–µ–∑–¥—ã:</span><b>${kidStarType(st.spec)}</b></div>
        <div class="row"><span class="label">–†–∞–∑–º–µ—Ä:</span><b>${kidSize(st.rsun)}</b></div>
        <div class="row"><span class="label">–ù–∞—Å–∫–æ–ª—å–∫–æ –¥–∞–ª–µ–∫–æ:</span><b>${kidDistance(st.distLy)}</b></div>
        <div class="row"><span class="label">–°–µ–π—á–∞—Å:</span><b>${phaseText}</b></div>
      `;
    }

    function setDetails(st, show){
      if (!show){
        elDetails.style.display = "none";
        return;
      }
      elDetails.style.display = "block";
      elFact.textContent = st.fact || "‚Äî";
      elPlanets.innerHTML = "";

      const list = st.planets || [];
      if (!list.length){
        const li = document.createElement("li");
        li.textContent = "–ü–ª–∞–Ω–µ—Ç—ã: –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏.";
        elPlanets.appendChild(li);
        return;
      }

      list.forEach(p => {
        const li = document.createElement("li");
        if (p.name === "(–ø–æ–∫–∞ –Ω–µ—Ç)") {
          li.textContent = p.simple;
        } else {
          const bits = [];
          bits.push(p.name);
          if (p.status) bits.push(`(${p.status})`);
          if (p.simple) bits.push(`‚Äî ${p.simple}`);
          const extra = [];
          if (p.period && p.period !== "‚Äî") extra.push(`–≥–æ–¥: ${p.period}`);
          if (p.au && p.au !== "‚Äî") extra.push(`—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${p.au}`);
          li.textContent = bits.join(" ") + (extra.length ? ` [${extra.join(", ")}]` : "");
        }
        elPlanets.appendChild(li);
      });
    }

    // --------------------------
    // –ó–í–£–ö (WebAudio)
    // --------------------------
    const audio = {
      ctx: null, master: null,
      engineGain: null, engineFilter: null, engineOsc: null,
      engineLfo: null, engineLfoGain: null,
      engineNoiseSrc: null, engineNoiseGain: null,
      musicGain: null, padFilter: null, delay: null, delayFb: null,
      pad1: null, pad2: null, pad3: null,
      musicLfo: null, musicLfoGain: null,
      started: false,
    };

    function makeNoiseBuffer(ctx, seconds = 1.0){
      const sampleRate = ctx.sampleRate;
      const len = Math.floor(sampleRate * seconds);
      const buf = ctx.createBuffer(1, len, sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * 0.35;
      return buf;
    }

    function initAudioIfNeeded(){
      if (audio.started) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;

      const ctx = new AudioCtx();
      audio.ctx = ctx;

      const master = ctx.createGain();
      master.gain.value = 0.35;
      master.connect(ctx.destination);
      audio.master = master;

      // engine
      const engineGain = ctx.createGain(); engineGain.gain.value = 0.0;
      const engineFilter = ctx.createBiquadFilter();
      engineFilter.type = "bandpass";
      engineFilter.frequency.value = 700;
      engineFilter.Q.value = 1.2;

      const engineOsc = ctx.createOscillator();
      engineOsc.type = "triangle";
      engineOsc.frequency.value = 240;

      const engineLfo = ctx.createOscillator();
      engineLfo.type = "sine";
      engineLfo.frequency.value = 7.0;

      const engineLfoGain = ctx.createGain();
      engineLfoGain.gain.value = 45;

      engineLfo.connect(engineLfoGain);
      engineLfoGain.connect(engineOsc.frequency);

      const noiseSrc = ctx.createBufferSource();
      noiseSrc.buffer = makeNoiseBuffer(ctx, 1.0);
      noiseSrc.loop = true;

      const noiseGain = ctx.createGain();
      noiseGain.gain.value = 0.0;

      engineOsc.connect(engineFilter);
      noiseSrc.connect(noiseGain);
      noiseGain.connect(engineFilter);

      engineFilter.connect(engineGain);
      engineGain.connect(master);

      engineOsc.start();
      engineLfo.start();
      noiseSrc.start();

      audio.engineGain = engineGain;
      audio.engineFilter = engineFilter;
      audio.engineOsc = engineOsc;
      audio.engineLfo = engineLfo;
      audio.engineLfoGain = engineLfoGain;
      audio.engineNoiseSrc = noiseSrc;
      audio.engineNoiseGain = noiseGain;

      // music
      const musicGain = ctx.createGain();
      musicGain.gain.value = 0.0;
      musicGain.connect(master);
      audio.musicGain = musicGain;

      const padFilter = ctx.createBiquadFilter();
      padFilter.type = "lowpass";
      padFilter.frequency.value = 520;
      padFilter.Q.value = 0.6;

      const delay = ctx.createDelay(1.0);
      delay.delayTime.value = 0.35;
      const delayFb = ctx.createGain();
      delayFb.gain.value = 0.35;

      delay.connect(delayFb);
      delayFb.connect(delay);

      padFilter.connect(musicGain);
      padFilter.connect(delay);
      delay.connect(musicGain);

      audio.padFilter = padFilter;
      audio.delay = delay;
      audio.delayFb = delayFb;

      const pad1 = ctx.createOscillator(); pad1.type = "sine";
      const pad2 = ctx.createOscillator(); pad2.type = "triangle";
      const pad3 = ctx.createOscillator(); pad3.type = "sine";

      pad1.frequency.value = 220 * 0.5;
      pad2.frequency.value = 261.63 * 0.5;
      pad3.frequency.value = 329.63 * 0.5;

      const det1 = ctx.createGain(); det1.gain.value = 0.33;
      const det2 = ctx.createGain(); det2.gain.value = 0.22;
      const det3 = ctx.createGain(); det3.gain.value = 0.18;

      pad1.connect(det1); pad2.connect(det2); pad3.connect(det3);
      det1.connect(padFilter); det2.connect(padFilter); det3.connect(padFilter);

      const musicLfo = ctx.createOscillator();
      musicLfo.type = "sine";
      musicLfo.frequency.value = 0.08;

      const musicLfoGain = ctx.createGain();
      musicLfoGain.gain.value = 220;

      musicLfo.connect(musicLfoGain);
      musicLfoGain.connect(padFilter.frequency);

      pad1.start(); pad2.start(); pad3.start();
      musicLfo.start();

      audio.pad1 = pad1; audio.pad2 = pad2; audio.pad3 = pad3;
      audio.musicLfo = musicLfo; audio.musicLfoGain = musicLfoGain;

      audio.started = true;
    }

    async function resumeAudio(){
      if (!audio.started) initAudioIfNeeded();
      if (audio.ctx && audio.ctx.state !== "running"){
        try { await audio.ctx.resume(); } catch {}
      }
      if (audio.ctx && audio.musicGain && audio.musicGain.gain.value < 0.0001){
        const t = audio.ctx.currentTime;
        audio.musicGain.gain.cancelScheduledValues(t);
        audio.musicGain.gain.setValueAtTime(0.0, t);
        audio.musicGain.gain.linearRampToValueAtTime(0.10, t + 1.6);
      }
    }

    function setMusicLevel(level){
      if (!audio.started || !audio.ctx || !audio.musicGain) return;
      const t = audio.ctx.currentTime;
      audio.musicGain.gain.cancelScheduledValues(t);
      audio.musicGain.gain.setValueAtTime(audio.musicGain.gain.value, t);
      audio.musicGain.gain.linearRampToValueAtTime(level, t + 0.25);
    }

    function setEngine(on, intensity = 1){
      if (!audio.started || !audio.ctx) return;
      const ctx = audio.ctx;

      const vol = on ? (0.10 + 0.10 * intensity) : 0.0;
      const noiseVol = on ? (0.02 + 0.03 * intensity) : 0.0;

      audio.engineGain.gain.cancelScheduledValues(ctx.currentTime);
      audio.engineGain.gain.setValueAtTime(audio.engineGain.gain.value, ctx.currentTime);
      audio.engineGain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 0.08);

      audio.engineNoiseGain.gain.cancelScheduledValues(ctx.currentTime);
      audio.engineNoiseGain.gain.setValueAtTime(audio.engineNoiseGain.gain.value, ctx.currentTime);
      audio.engineNoiseGain.gain.linearRampToValueAtTime(noiseVol, ctx.currentTime + 0.08);

      const base = on ? (260 + 110 * intensity) : 240;
      audio.engineOsc.frequency.setTargetAtTime(base, ctx.currentTime, 0.06);

      const f = on ? (700 + 700 * intensity) : 700;
      audio.engineFilter.frequency.setTargetAtTime(f, ctx.currentTime, 0.08);
    }

    // --------------------------
    // –û–ó–í–£–ß–ö–ê (Web Speech API) ‚Äî –ü–´–¢–ê–ï–ú–°–Ø –í–´–ë–†–ê–¢–¨ –ú–£–ñ–°–ö–û–ô –†–£–°–°–ö–ò–ô –ì–û–õ–û–°
    // --------------------------
    const tts = {
      supported: "speechSynthesis" in window && "SpeechSynthesisUtterance" in window,
      voice: null,
      done: true,
    };

    function scoreRussianVoice(v){
      const lang = (v.lang || "").toLowerCase();
      if (!lang.startsWith("ru")) return -999;

      const name = (v.name || "").toLowerCase();
      const uri  = (v.voiceURI || "").toLowerCase();

      // –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ ‚Äú–º—É–∂—Å–∫–æ–≥–æ‚Äù –≥–æ–ª–æ—Å–∞ (—á–∞—Å—Ç–æ —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –≥–æ–ª–æ—Å–∞ –≤ Windows/Edge/Android)
      const maleHints = [
        "male","–º—É–∂","pavel","–¥–º–∏—Ç","dmit","yuri","—é—Ä–∏","alek","–∞–ª–µ–∫",
        "serg","—Å–µ—Ä–≥","ivan","–∏–≤–∞–Ω","vlad","–≤–ª–∞–¥","andrei","–∞–Ω–¥—Ä–µ",
        "maxim","–º–∞–∫—Å–∏–º","nikol","–Ω–∏–∫–æ–ª"
      ];
      // –∂–µ–Ω—Å–∫–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ (—á—Ç–æ–±—ã —á—É—Ç—å –æ—Ç–æ–¥–≤–∏–Ω—É—Ç—å)
      const femaleHints = ["female","–∂–µ–Ω","anna","–∞–Ω–Ω–∞","alena","–µ–ª–µ–Ω–∞","irina","–∏—Ä–∏–Ω–∞"];

      let score = 0;

      // –ª–æ–∫–∞–ª—å–Ω—ã–µ –≥–æ–ª–æ—Å–∞ —á–∞—Å—Ç–æ –∑–≤—É—á–∞—Ç –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–µ–µ
      if (v.localService) score += 4;
      if (v.default) score += 2;

      for (const w of maleHints) {
        if (name.includes(w) || uri.includes(w)) { score += 12; break; }
      }
      for (const w of femaleHints) {
        if (name.includes(w) || uri.includes(w)) { score -= 6; break; }
      }

      // –Ω–µ–º–Ω–æ–≥–æ ‚Äú–ø—Ä–µ–º–∏–∏‚Äù –∑–∞ Microsoft-–≥–æ–ª–æ—Å–∞ (—á–∞—Å—Ç–æ –±—ã–≤–∞—é—Ç –±–æ–ª–µ–µ ‚Äú–º—É–∂—Å–∫–∏–º–∏‚Äù –∏ —á—ë—Ç–∫–∏–º–∏)
      if (name.includes("microsoft")) score += 3;

      return score;
    }

    function pickRussianMaleVoice(){
      if (!tts.supported) return;
      const voices = window.speechSynthesis.getVoices?.() || [];
      const ru = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ru"));
      if (!ru.length) { tts.voice = null; return; }

      // –≤—ã–±–∏—Ä–∞–µ–º —Å –ª—É—á—à–∏–º —Å–∫–æ—Ä–æ–º
      let best = ru[0];
      let bestScore = scoreRussianVoice(best);
      for (const v of ru.slice(1)){
        const s = scoreRussianVoice(v);
        if (s > bestScore){
          bestScore = s;
          best = v;
        }
      }
      tts.voice = best || null;

      // –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å, —á—Ç–æ –≤—ã–±—Ä–∞–ª–æ—Å—å:
      // console.log("Chosen RU voice:", tts.voice?.name, tts.voice?.lang, "score=", bestScore);
    }

    if (tts.supported){
      pickRussianMaleVoice();
      window.speechSynthesis.onvoiceschanged = () => pickRussianMaleVoice();
    }

    function planetsTextForSpeech(st){
      const list = st.planets || [];
      if (!list.length) return "–ü–ª–∞–Ω–µ—Ç—ã –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏.";
      if (list.length === 1 && list[0].name === "(–ø–æ–∫–∞ –Ω–µ—Ç)") return list[0].simple || "–ü–ª–∞–Ω–µ—Ç—ã –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏.";
      const items = list.map(p => {
        if (p.name === "(–ø–æ–∫–∞ –Ω–µ—Ç)") return p.simple || "–ø–ª–∞–Ω–µ—Ç—ã –ø–æ–∫–∞ –Ω–µ –Ω–∞—à–ª–∏";
        const parts = [];
        parts.push(p.name);
        if (p.status) parts.push(p.status);
        if (p.simple) parts.push(p.simple);
        return parts.join(", ");
      });
      return "–ü–ª–∞–Ω–µ—Ç—ã: " + items.join(". ") + ".";
    }

    function buildSpeechText(st){
      const a = [];
      a.push(`–ú—ã –ø—Ä–∏–ª–µ—Ç–µ–ª–∏ –∫ –∑–≤–µ–∑–¥–µ ${st.ruName}.`);
      a.push(`–¢–∏–ø: ${kidStarType(st.spec)}.`);
      a.push(`–†–∞–∑–º–µ—Ä: ${kidSize(st.rsun)}.`);
      a.push(`–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${kidDistance(st.distLy)}.`);
      if (st.fact) a.push(`–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π —Ñ–∞–∫—Ç: ${st.fact}`);
      a.push(planetsTextForSpeech(st));
      return a.join(" ");
    }

    function speakStarInfo(st){
      if (!tts.supported) { tts.done = true; return; }
      try { window.speechSynthesis.cancel(); } catch {}

      // –ø–æ–ø—ã—Ç–∫–∞ –æ–±–Ω–æ–≤–∏—Ç—å –≥–æ–ª–æ—Å–∞ –ø—Ä—è–º–æ –ø–µ—Ä–µ–¥ –æ–∑–≤—É—á–∫–æ–π (–∏–Ω–æ–≥–¥–∞ –±—Ä–∞—É–∑–µ—Ä –ø–æ–¥–≥—Ä—É–∂–∞–µ—Ç –ø–æ–∑–∂–µ)
      pickRussianMaleVoice();

      const u = new SpeechSynthesisUtterance(buildSpeechText(st));
      u.lang = "ru-RU";
      if (tts.voice) u.voice = tts.voice;

      // ‚úÖ ‚Äú–º—É–∂—Å–∫–æ–π‚Äù —ç—Ñ—Ñ–µ–∫—Ç: —á—É—Ç—å –Ω–∏–∂–µ –ø–∏—Ç—á, –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
      u.rate = 1.0;
      u.pitch = 0.82;
      u.volume = 1.0;

      tts.done = false;
      setMusicLevel(0.05);

      u.onend = () => { tts.done = true; setMusicLevel(0.10); };
      u.onerror = () => { tts.done = true; setMusicLevel(0.10); };

      try { window.speechSynthesis.speak(u); }
      catch { tts.done = true; setMusicLevel(0.10); }
    }

    // --------------------------
    // –ü–û–õ–Å–¢
    // --------------------------
    const Phase = { WAIT:"WAIT", GO:"GO", HOLD:"HOLD", RETURN:"RETURN" };
    let idx = 0;
    let phase = Phase.WAIT;

    const HOLD_MIN_SECONDS = 20.0;
    const SPEED_GO = 0.38;
    const SPEED_BACK = 1.25;

    let spaceDown = false;
    let goS = 0;
    let backS = 0;
    let holdT = 0;

    let p0 = new THREE.Vector3();
    let p1 = new THREE.Vector3();
    let p2 = new THREE.Vector3();
    let arrivePos = new THREE.Vector3();
    let arc = null;

    const sunDock = new THREE.Vector3(0, 0.0, 0.10);
    ship.position.copy(sunDock);

    function rotateShipToward(prev, cur){
      const dx = cur.x - prev.x;
      const dy = cur.y - prev.y;
      if (dx*dx + dy*dy < 1e-10) return;
      ship.rotation.z = Math.atan2(dy, dx);
    }

    function setCameraTargetForStar(st){
      const d = st.distLy;
      camFrameTarget.center.copy(st.pos).multiplyScalar(0.5);
      const margin = Math.max(1.1, d * 0.14);
      const desiredHalf = (d / 2) + margin;
      const baseHalf = Math.max(2.7, desiredHalf * 0.90);
      camFrameTarget.halfH = baseHalf * userZoom;
    }

    function setupTarget(){
      const st = STARS[idx];

      visibleRings = Math.min(12, Math.ceil(st.distLy + 1));
      updateRings();

      starRays.forEach((ln, i) => ln.material.opacity = (i === idx ? 0.20 : 0.05));

      const dir = st.pos.clone().normalize();
      arrivePos = st.pos.clone().sub(dir.multiplyScalar(0.60));
      arrivePos.z = 0.10;

      p0 = sunDock.clone();
      p2 = arrivePos.clone();

      const mid = p0.clone().lerp(p2, 0.5);
      const perp = new THREE.Vector3(-dir.y, dir.x, 0);
      const bend = Math.min(2.0, Math.max(0.65, st.distLy * 0.20));
      p1 = mid.add(perp.multiplyScalar(bend));
      p1.z = 0.10;

      arc = buildArcSamples(p0, p1, p2, 800);

      setCameraTargetForStar(st);

      const sizeText = kidSize(st.rsun);
      const lyInt = Math.max(1, Math.round(st.distLy));
      flName.textContent = st.ruName;
      flMeta.textContent = `${kidStarType(st.spec)} ‚Ä¢ ${sizeText} ‚Ä¢ ${lyInt} —Å–≤–µ—Ç–æ–≤—ã—Ö –ª–µ—Ç`;

      setDetails(st, false);
      elBar.style.width = "0%";
      setInfo(st, "–ñ–¥—ë–º‚Ä¶ –¥–µ—Ä–∂–∏ –ü–†–û–ë–ï–õ, —á—Ç–æ–±—ã –ª–µ—Ç–µ—Ç—å üöÄ");

      goS = 0;
      backS = 0;
      holdT = 0;
      tts.done = true;
    }

    setupTarget();

    window.addEventListener("keydown", async (e) => {
      if (e.code === "Space") e.preventDefault();
      if (e.code !== "Space") return;

      spaceDown = true;
      await resumeAudio();

      if (phase === Phase.WAIT){
        phase = Phase.GO;
      }
    }, { passive: false });

    window.addEventListener("keyup", (e) => {
      if (e.code !== "Space") return;
      spaceDown = false;
    });

    function updateFloating(st){
      const s2 = projectToScreen(st.pos.clone().setZ(0), camera);
      floating.style.left = s2.x + "px";
      floating.style.top = s2.y + "px";
      floating.style.opacity = s2.inFront ? "1" : "0";
    }

    function setThrustVisual(on){
      flame.material.opacity = on ? (0.25 + 0.20*Math.random()) : 0.0;
      ship.scale.setScalar(on ? (1.0 + 0.015*Math.sin(performance.now()*0.02)) : 1.0);
    }

    let last = performance.now();
    let prevShipPos = ship.position.clone();
    let holdSpeechStarted = false;

    function enterHold(st){
      holdT = 0;
      holdSpeechStarted = true;
      setDetails(st, true);
      speakStarInfo(st);
    }

    function updateHoldUI(st){
      const minLeft = Math.max(0, Math.ceil(HOLD_MIN_SECONDS - holdT));
      if (!tts.supported){
        setInfo(st, `–ú—ã –ø—Ä–∏–ª–µ—Ç–µ–ª–∏! (–µ—â—ë ${minLeft} —Å–µ–∫)`);
        return;
      }
      if (!tts.done){
        setInfo(st, `–ú—ã –ø—Ä–∏–ª–µ—Ç–µ–ª–∏! –°–µ–π—á–∞—Å —è –æ–∑–≤—É—á–∏–≤–∞—é üëá`);
      } else {
        setInfo(st, `–ì–æ—Ç–æ–≤–æ! –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è —á–µ—Ä–µ–∑ ${minLeft} —Å–µ–∫`);
      }
    }

    function canLeaveHold(){
      const timeOk = holdT >= HOLD_MIN_SECONDS;
      const speechOk = !tts.supported ? true : tts.done;
      return timeOk && speechOk;
    }

    function animate(now){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      const st = STARS[idx];

      setCameraTargetForStar(st);
      updateOrthoSmooth(dt);

      sunHalo.material.opacity = 0.11 + 0.05*Math.sin(now*0.0022);

      if (phase === Phase.WAIT){
        ship.position.copy(sunDock);
        ship.position.y += 0.04 * Math.sin(now * 0.003);
        ship.rotation.z = 0;

        setInfo(st, "–ñ–¥—ë–º‚Ä¶ –¥–µ—Ä–∂–∏ –ü–†–û–ë–ï–õ, —á—Ç–æ–±—ã –ª–µ—Ç–µ—Ç—å üöÄ");
        setDetails(st, false);
        elBar.style.width = "0%";

        setThrustVisual(false);
        setEngine(false, 0);

        goS = 0; backS = 0; holdT = 0;
        holdSpeechStarted = false;
      }

      if (phase === Phase.GO){
        if (spaceDown){
          goS = Math.min(arc.total, goS + SPEED_GO * dt);
        }

        const t = tForArcLen(arc, goS);
        const pos = bezier(p0, p1, p2, t);
        pos.z = 0.10;

        rotateShipToward(prevShipPos, pos);
        ship.position.copy(pos);
        prevShipPos.copy(pos);

        const pct = Math.round((goS / arc.total) * 100);
        setInfo(st, spaceDown ? `–õ–µ—Ç–∏–º‚Ä¶ (—Å–∫–æ—Ä–æ—Å—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤–∞—è) ${pct}%` : `–ü–∞—É–∑–∞‚Ä¶ –¥–µ—Ä–∂–∏ –ü–†–û–ë–ï–õ (${pct}%)`);
        setDetails(st, false);
        elBar.style.width = `${pct}%`;

        setThrustVisual(spaceDown);
        setEngine(spaceDown, 1.0);

        if (goS >= arc.total - 1e-6){
          phase = Phase.HOLD;
          holdSpeechStarted = false;
          setThrustVisual(false);
          setEngine(false, 0);
        }
      }

      if (phase === Phase.HOLD){
        ship.position.copy(arrivePos);

        if (!holdSpeechStarted){
          enterHold(st);
        }

        holdT += dt;
        elBar.style.width = "100%";
        setThrustVisual(false);
        setEngine(false, 0);

        updateHoldUI(st);

        if (canLeaveHold()){
          if (tts.supported) { try { window.speechSynthesis.cancel(); } catch {} }
          phase = Phase.RETURN;
          backS = 0;
          setDetails(st, false);
          holdSpeechStarted = false;
        }
      }

      if (phase === Phase.RETURN){
        backS = Math.min(arc.total, backS + SPEED_BACK * dt);
        const sFromStart = Math.max(0, arc.total - backS);
        const t = tForArcLen(arc, sFromStart);

        const pos = bezier(p0, p1, p2, t);
        pos.z = 0.10;

        rotateShipToward(prevShipPos, pos);
        ship.position.copy(pos);
        prevShipPos.copy(pos);

        const pctLeft = Math.round((sFromStart / arc.total) * 100);
        setInfo(st, `–ë—ã—Å—Ç—Ä–æ –¥–æ–º–æ–π‚Ä¶ (${pctLeft}%)`);
        setDetails(st, false);
        elBar.style.width = `${pctLeft}%`;

        setThrustVisual(true);
        setEngine(true, 0.85);

        if (backS >= arc.total - 1e-6){
          idx = (idx + 1) % STARS.length;
          phase = Phase.WAIT;
          ship.position.copy(sunDock);
          prevShipPos.copy(sunDock);
          setupTarget();
        }
      }

      updateFloating(st);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    // --------------------------
    // Resize
    // --------------------------
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      applyOrthoFrame(camFrame);
    });

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") e.preventDefault();
    }, { passive: false });

  </script>
</body>
</html>
